#!/usr/bin/python3

import sys
import numpy as np
from math import floor

if len(sys.argv) <= 3:
    print("gen_xvec_lbl.py <segments_file> <frame_size> <stride>")
    print("You need to enter the segments file")
    print("generated by generate_segments.py")
    print("Second and third parameter need to be")
    print("length and strade of the frame used")
    print("to generate xvectors over.")
    print("The length needs to be enterd in 10ms units")
    print("A frame of 150ms therefore has needs to be entered as 15.")
    print("Stride can be float values")
    exit(1)

segments_file_name = sys.argv[1]
frame_size = int(sys.argv[2])
half_frame = frame_size/2
stride = float(sys.argv[3])


def read_segments(file_name):
    convs = {}

    segments = []
    current_conv = ""
    mfcc_pos = 0
    for seg in open(file_name).readlines():
        seg = seg.replace("\n", "").split(" ")
        cid = seg[0]
        sid = seg[1]
        start = int(seg[2])
        stop = int(seg[3])

        # save last count of segments
        if not current_conv == cid and not current_conv == "":
            convs[current_conv] = segments
            segments = []
            mfcc_pos = 0
        
        current_conv = cid
        seg_dur = stop - start  
        segments.append({"sid":sid, "mfcc_pos":mfcc_pos, "time_pos":start, "dur":seg_dur})
        mfcc_pos += seg_dur
    
    if len(segments) > 0:
        convs[current_conv] = segments

    return convs


def get_mfcc_count_of_segments(segments):
    count = 0
    for seg in segments:
        count += seg["dur"]
    return count


def get_count_of_frames(mfcc_count):
    return int((mfcc_count - frame_size) / stride) + 1


def get_speaker_of_segments(segments):
    speaker = {}
    i = 1
    for s in segments:
        if not s["sid"] in speaker:
            speaker[s["sid"]] = i
            i += 1
    return speaker


def get_touching_segments(segments, start, stop):
    touching_segments = []
    for seg in segments:
        if seg["mfcc_pos"] < stop and seg["mfcc_pos"] + seg["dur"] >= start: 
            touch_start = seg["time_pos"] if seg["mfcc_pos"] >= start else (seg["time_pos"] - seg["mfcc_pos"] + start)
            touch_end = (seg["time_pos"] + seg["dur"]) if seg["mfcc_pos"] + seg["dur"] <= stop else (seg["time_pos"] - seg["mfcc_pos"] + stop)
            touching_segments.append((seg, touch_start, touch_end))
    return touching_segments

def label_frames_by_segments(conv_id, segments):
    frames = np.zeros(get_count_of_frames(get_mfcc_count_of_segments(segments)))
    speaker = get_speaker_of_segments(segments)

    for i in range(0, frames.shape[0]):
        frame_center = i * stride + half_frame
        sids_of_frame = []
        touch_starts_of_frame = []
        touch_ends_of_frame = []
        for seg in get_touching_segments(segments, frame_center - half_frame, frame_center + half_frame):
            sids_of_frame.append(seg[0]["sid"])
            touch_starts_of_frame.append(str(int(seg[1])))
            touch_ends_of_frame.append(str(int(seg[2])))
        sids_of_frame = "-".join(sids_of_frame)
        touch_starts_of_frame = "-".join(touch_starts_of_frame)
        touch_ends_of_frame = "-".join(touch_ends_of_frame)

        print(f"{conv_id} {i} {sids_of_frame} {touch_starts_of_frame} {touch_ends_of_frame}")


convs = read_segments(segments_file_name)
for i in convs:
    label_frames_by_segments(i, convs[i]) 
   
